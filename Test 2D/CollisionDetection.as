package  {	import flash.display.BitmapData;	import flash.display.BitmapDataChannel;	import flash.display.BlendMode;	import flash.display.DisplayObject;	import flash.display.DisplayObjectContainer;	import flash.geom.Matrix;	import flash.geom.Point;	import flash.geom.Rectangle; 	/**	 * Tester une collision entre 2 DisplayObject	 */	public final class CollisionDetection { 		public static function testCollision(target1:DisplayObject, target2:DisplayObject, commonParent:DisplayObjectContainer):Boolean {			// get bounding boxes in common parent's coordinate space			var rect1:Rectangle = target1.getBounds(commonParent);			var rect2:Rectangle = target2.getBounds(commonParent);			// find the intersection of the two bounding boxes			var intersectionRect:Rectangle = rect1.intersection(rect2);			if (intersectionRect.size.length >  0) {				// size of rect needs to integer size for bitmap data				intersectionRect.width = Math.ceil(intersectionRect.width);				intersectionRect.height = Math.ceil(intersectionRect.height);				// get the alpha maps for the display objects				var alpha1:BitmapData = getAlphaMap(target1, intersectionRect, BitmapDataChannel.RED, commonParent);				var alpha2:BitmapData = getAlphaMap(target2, intersectionRect, BitmapDataChannel.GREEN, commonParent);				// combine the alpha maps				alpha1.draw(alpha2, null, null, BlendMode.LIGHTEN);				// calculate the search color				var searchColor:uint = 0x010100;				// find color				var collisionRect:Rectangle = alpha1.getColorBoundsRect(searchColor, searchColor);				collisionRect.x += intersectionRect.x;				collisionRect.y += intersectionRect.y;				if (collisionRect != null && collisionRect.size.length > 0) {					return true;				}				return false;			}else{				// no intersection				return false;			}		} 		private static function getAlphaMap(target:DisplayObject, rect:Rectangle, channel:uint, commonParent:DisplayObjectContainer):BitmapData	{			// calculate the transform for the display object relative to the common parent			var parentXformInvert:Matrix = commonParent.transform.concatenatedMatrix.clone();			parentXformInvert.invert();			var targetXform:Matrix = target.transform.concatenatedMatrix.clone();			targetXform.concat(parentXformInvert);			// translate the target into the rect's space			targetXform.translate(-rect.x, -rect.y);			// draw the target and extract its alpha channel into a color channel			var bitmapData:BitmapData = new BitmapData(rect.width, rect.height, true, 0);			bitmapData.draw(target, targetXform);			var alphaChannel:BitmapData = new BitmapData(rect.width, rect.height, false, 0);			alphaChannel.copyChannel(bitmapData, bitmapData.rect, new Point(0, 0), BitmapDataChannel.ALPHA, channel);			return alphaChannel;		}	}}